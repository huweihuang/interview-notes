# Golang面试题

# 1. 并发篇

## 1.1. 进程、线程、协程的区别

- 进程

进程是资源分配的单位，即资源隔离。同进程内的所有线程可以共同访问该进程的资源，每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

- 线程

线程是独立调度和运行的基本单位，线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

- 协程

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程没有线程的上下文切换消耗，

## 1.2. 并发和并行的区别

- 并发（**Concurrent**）：并存的，一个CPU同时做多件事，实际是在不断地切换时间片去做多件事，看起来像是同时在做多件事。例如：CPU在时间片1中做任务A，时间片2中做任务B，时间片3中再做任务A，时间片4中再做任务B，不断在多个任务之间来回切换执行。

- 并行（**Parallel**）：平行的，多个CPU同时做多件事，CPU1做任务A，CPU2做任务B，不同CPU做不同时的任务，互不干扰。

并行由于有多个CPU分别做不同的任务，并不会互相抢占资源。并发是由一个CPU做多个任务，因此存在抢占资源，切换任务的操作。

# 2. 概念篇

## 2.1. defer

**defer**（中文翻译：推迟）主要用来推迟执行，即在函数结束之前执行某些操作，其中函数结束主要包括return和panic两种情况，即正常结束和异常结束。

- defer的执行顺序
  
  - defer在声明时不会执行，而是推迟执行，在return前执行，defer的执行顺序是先进后出，倒序依次执行不同的defer语句。

- defer的特性
  
  - 即使函数抛出异常，defer仍会被执行，这样不会出现程序错误导致资源不被释放，或者因为第三方包的异常导致程序崩溃。

- defer的作用
  
  - 用来释放资源（关闭文件等）、清理数据、记录日志、异常处理等，因此不管函数是否正常结束，都会在结束前逆序执行defer语句。

## 2.2. recover

（recover）内建函数被用于从 panic 或 错误场景中恢复：让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行。`recover` 只能在 defer 修饰的函数中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用 `recover` 会返回 nil，且没有其它效果。

## 2.3. 闭包

参考： [A Tour of Go](https://tour.golang.org/moretypes/25)

常用在go和defer中。

闭包是指引用了函数外的变量的一种函数，这样该函数就被绑定在某个变量上。

匿名函数同样被称之为闭包（函数式语言的术语）：它们被允许调用定义在其它环境下的变量。闭包可使得某个函数捕捉到一些外部状态，例如：函数被创建时的状态。另一种表示方式为：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁，

闭包是包含自由变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。由于自由变量包含在代码块中，所以只要闭包还被使用，那么这些自由变量以及它们引用的对象就不会被释放，要执行的代码为自由变量提供绑定的计算环境。

闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。

### 2.3.1. golang for range中的闭包

[Frequently Asked Questions (FAQ) - The Go Programming Language](https://golang.org/doc/faq#closures_and_goroutines)

[CommonMistakes · golang/go Wiki · GitHub](https://github.com/golang/go/wiki/CommonMistakes)

在for range中goroutine的方式使用闭包，如果没有给匿名函数传入一个变量，或新建一个变量存储迭代的变量，那么goroutine执行的结果会是最后一个迭代变量的结果，而不是每个迭代变量的结果。这是因为如果没有通过一个变量来拷贝迭代变量，那么闭包因为绑定了变量，当每个groutine运行时，迭代变量可能被更改。

```go
// false, print 3 3 3
values := []int{1,2,3}
for _, val := range values {
    go func() {
        fmt.Println(val)
    }()
}
// true, print 1 2 3
for _, val := range values {
    go func(val interface{}) {
        fmt.Println(val)
    }(val)
}
```

# 3. 原理篇

## 3.1. Goroutine调度模型

### 3.1.1. 简单介绍一下go的调度模型

参考：[The Go scheduler - Morsing's blog](http://morsmachine.dk/go-scheduler)

1. 首先，Goroutine的调度是通过GPM模型来实现的。其中
- G：goroutine，代表goroutine，即执行的goroutine的数据结构及栈等。（我们可以把它比喻成砖头）

- P：processor，代表调度执行的上下文（context），维护了一个本地的goroutine的队列。（我们可以把它比喻成小推车）

- M：machine，代表系统内核进程，用来执行G。（我们可以把它比喻成工人）
2. 其次，调度的本质是将G尽量均匀合理地安给M来执行，其中P的作用就是来实现合理安排逻辑。
- P的数量通过 `GOMAXPROCS()` 来设置，一般等于CPU的核数，对于一次代码执行设置好一般不会变。

- P维护了一个本地的G队列，包括正在执行和待执行的G，尽量保证所有的P都匹配一个M同时在执行G。

- P和M是动态形式的一对一的关系，P和G是动态形式的一对多的关系。

P存在的原因：

1. 当goroutine发生阻塞的时候，可以通过P将剩余的G切换给新的M来执行，而不会导致剩余的G无法执行，如果没有M则创建M来匹配P。
2. P可以偷任务即goroutine，当某个P的本地G执行完，且全局没有G需要执行的时候，P可以去偷别的P还没有执行完的一半的G来给M执行，提高了G的执行效率。

### 3.1.2. GPM模型，为什么需要P?

- 没有P带来的问题：

早期Go中的调度器直接将G分配到合适的M上运行。但这样带来了很多问题，例如，不同的G在不同的M上并发运行时可能都需向系统申请资源（如堆内存），由于资源是全局的，将会由于资源竞争造成很多系统性能损耗。

- P解决的问题

后面的Go（Go1.1）运行时系统加入了P，让P去管理G对象，M要想运行G必须先与一个P绑定，然后才能运行该P管理的G。这样带来的好处是，我们可以在P对象中预先申请一些系统资源（本地资源），G需要的时候先向自己的本地P申请（无需锁保护），如果不够用或没有再向全局申请，而且从全局拿的时候会多拿一部分，以供后面高效的使用。

就像现在我们去政府办事情一样，先去本地政府看能搞定不，如果搞不定再去中央，从而提供办事效率。 而且由于P解耦了G和M对象，这样即使M由于被其上正在运行的G阻塞住，其余与该M关联的G也可以随着P一起迁移到别的活跃的M上继续运行，从而让G总能及时找到M并运行自己，从而提高系统的并发能力。 

Go运行时系统通过构造G-P-M对象模型实现了一套用户态的并发调度系统，可以自己管理和调度自己的并发任务，所以可以说Go语言**原生支持并发**。自己实现的调度器负责将并发任务分配到不同的内核线程上运行，然后内核调度器接管内核线程在CPU上的执行与调度。

## 3.2. 垃圾回收

### 3.2.1. 三色标记法

go的垃圾回收机制是通过三色标记法来实现的，其中

- 黑色：没有指向（引用）白色集合中的任何对象
- 灰色：可能指向（引用）白色集合中的某些对象
- 白色：剩下的需要被回收的候选对象，当灰色集合为空时，表示白色集合中的对象都没有被引用，那么这些对象就可以被回收。

一个垃圾回收循环的步骤：

1. 将所有的对象都放入白色集合中
2. 扫描所有roots对象，放入灰色集合中，roots对象表示在应用中可以被直接访问，一般是全局变量和其他在栈中的对象。
3. 将灰色集合中的某个对象放入黑色集合，然后扫描这个对象有引到到的白色集合中的对象，将那些白色集合中引用到的所有对象放入灰色集合，以此类推，将灰色集合中的对象不断放入黑色集合中，然后白色集合中的对象不断放入灰色集合中。
4. 当灰色集合中的对象为0，即都被放入到黑色集合中了，表示没有任何对象会引用到白色集合中的对象了，因为黑色集合存放不会引用白色集合对象的元素，而灰色集合为0，也不存在引用白色集合对象的元素。所以白色集合中的对象即是没有被引用的对象，可以回收的对象。

### 3.2.2. 三色标记和写屏障

这是让标记和⽤户代码并发的基本保障，基本原理：
• 起初所有对象都是⽩⾊。
• 扫描找出所有可达对象，标记为灰⾊，放⼊待处理队列。
• 从队列提取灰⾊对象，将其引⽤对象标记为灰⾊放⼊队列，⾃⾝标记为⿊⾊。
• 写屏障监视对象内存修改，重新标⾊或放回队列。
当完成全部扫描和标记⼯作后，剩余不是⽩⾊就是⿊⾊，分别代表要待回收和活跃对象，清理操作只需将⽩⾊对象内存收回即可。

### 3.2.3. 标记清除算法 (Mark-Sweep)

标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。

优点是简单，容易实现。
缺点是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。（因为没有对不同生命周期的对象采用不同算法，所以碎片多，内存容易满，gc频率高，耗时）

## 3.3. 内存分配

### 3.3.1. 内存分配器的问题

当给不同大小的变量分配连续地址的内存的时候，可能因为部分变量内存的回收导致在分配新的内存需求时无法利用被回收的内存地址，因此内存管理不当，容易导致内存的碎片。

### 3.3.2.基本策略：

1. 每次从操作系统申请⼀⼤块内存（⽐如 1MB），以减少系统调⽤。
2. 将申请到的⼤块内存按照特定⼤⼩预先切分成⼩块，构成链表。
3. 为对象分配内存时，只需从⼤⼩合适的链表提取⼀个⼩块即可。
4. 回收对象内存时，将该⼩块内存重新归还到原链表，以便复⽤。
5. 如闲置内存过多，则尝试归还部分内存给操作系统，降低整体开销

### 3.3.3.内存分配的本质

针对不同大小的对象，在不同的 cache 层中，使用不同的内存结构；将从系统中获得的一块连续内存分割成多层次的 cache，以减少锁的使用以提高内存分配效率；申请不同类大小的内存块来减少内存碎片，同时加速内存释放后的垃圾回收。

go的内存分配器将内存页分成67个不同大小规格（size class）的块，最小为8KB，最大为32768KB。

内存块的分类：

- span:由多个地址连续的页（page）组成的大块内存。面向内部管理。
- object：将span按照特定的大小切分成多个小块，每个小块可以存储一个对象。面向对象分配。

内存分配器的三个数据结构（申请逐级向上）：

- mcache：goroutine cache，可以认为是 本地 cache。不涉及锁竞争。
- mcentral：全局cache，mcache 不够用的时候向 mcentral 申请。涉及锁竞争。
- mheap：当mcentral 也不够用的时候，通过 mheap 向操作系统申请。

### 3.3.4.内存分配的流程

1. object size < 16K，使用 mcache 的小对象分配器 tiny 直接分配。
2. object size > 32K，则使用 mheap 直接分配。
3. object size > 16K && object size < 32K，先使用 mcache 中对应的 size class 分配。
4. 如果 mcache 对应的 size class 的 span 已经没有可用的块，则向 mcentral 请求。
5. 如果 mcentral 也没有可用的块，则向 mheap申请，并切分。
6. 如果 mheap 也没有合适的 span，则想操作系统申请。

### 3.3.5.内存回收的流程

- mcache 归还内存分两部分：归还mcentral内存，可能涉及锁竞争；除此之外，归还到mheap，直接插入链表头。
- mcentral 归还mheap。
- mheap 定时归还系统内存。

## 3.3.6.tcmalloc(thread-caching mallo)

是google推出的一种内存分配器。

具体策略：全局缓存堆和进程的私有缓存。

1.对于一些小容量的内存申请试用进程的私有缓存，私有缓存不足的时候可以再从全局缓存申请一部分作为私有缓存。

2.对于大容量的内存申请则需要从全局缓存中进行申请。而大小容量的边界就是32k。缓存的组织方式是一个单链表数组，数组的每个元素是一个单链表，链表中的每个元素具有相同的大小。

golang语言中MHeap就是全局缓存堆，MCache作为线程私有缓存。

内存池就是利用MHeap实现，大小切分则是在申请内存的时候就做了，同时MCache分配内存时，可以用MCentral去取对应的sizeClass，多线程管理方面则是通过MCache去实现。

总结:

1.MHeap是一个全局变量，负责向系统申请内存，mallocinit()函数进行初始化。如果分配内存对象大于32K直接向MHeap申请。

2.MCache线程级别管理内存池，关联结构体P，主要是负责线程内部内存申请。

3.MCentral连接MHeap与MCache的，MCache内存不够则向MCentral申请，MCentral不够时向MHeap申请内存。

## 3.4. channel的原理

channel的作用是解决goroutine之间的通信问题。不要通过共享内存来通信，而应该通过通信来共享内存。

### 3.4.1. channel的特性

- goroutine安全
- 提供FIFO语义(buffered channel提供)，缓冲大小
- 在不同的goroutine之间存储和传输值
- 可以让goroutine block/unblock

### 3.4.2. channel的数据结构

```go
type hchan struct {
    qcount   uint           // 当前队列中剩余元素个数
    dataqsiz uint           // 环形队列长度，即可以存放的元素个数
    buf      unsafe.Pointer // 环形队列指针
    elemsize uint16         // 每个元素的大小
    closed   uint32            // 标识关闭状态
    elemtype *_type         // 元素类型
    sendx    uint           // 队列下标，指示元素写入时存放到队列中的位置
    recvx    uint           // 队列下标，指示元素从队列的该位置读出
    recvq    waitq          // 等待读消息的goroutine队列
    sendq    waitq          // 等待写消息的goroutine队列
    lock mutex              // 互斥锁，chan不允许并发读写
}
```

hchan维护了两个链表，recvq是因读这个chan而阻塞的G，sendq则是因写这个chan而阻塞的G。waitq队列中每个元素的数据结构为sudog，其中elem用于保存数据。

### 3.4.3. 创建channel

make函数在创建channel的时候会在该进程的heap区申请一块内存，创建一个hchan结构体，返回执行该内存的指针，所以获取的的ch变量本身就是一个指针，在函数之间传递的时候是同一个channel。

hchan结构体使**用一个环形队列**来保存groutine之间传递的数据(如果是缓存channel的话)，使用**两个list**保存像该chan发送和从改chan接收数据的goroutine，还有一个mutex来保证操作这些结构的安全。

### 3.4.4. 写入channel

recvq存放读取channel阻塞的G，此时说明channel里面没有数据。sendq存放写入channel阻塞的G，此时说明channel已经满了。

1. 如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该recvq的G唤醒，结束发送过程；
2. 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；
3. 如果缓冲区满了，将待发送数据写入G，将当前G加入sendq，进入睡眠（阻塞状态），等待被读goroutine唤醒；

### 3.4.5. 读出channel

1. 如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；
2. 如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；
3. 如果等待发送队列sendq为空，说明缓冲区中有数据，则从缓冲区取出数据，结束读取过程；
4. 如果channel读取不到数据，将当前goroutine加入recvq，进入睡眠（阻塞状态），等待被写goroutine唤醒；

### 3.4.6. 关闭channel

- 将 c.closed 设置为 1

- 唤醒 recvq 队列里面的阻塞 goroutine

- 唤醒 sendq 队列里面的阻塞 goroutine

### 3.4.7. 阻塞

当G1向buf已经满了的ch发送数据的时候，当runtine检测到对应的hchan的buf已经满了，会通知调度器，调度器会将G1的状态设置为waiting, 移除与线程M的联系，然后从P的runqueue中选择一个goroutine在线程M中执行，此时G1就是阻塞状态，但是不是操作系统的线程阻塞，所以这个时候只用消耗少量的资源。

### 3.4.8. 唤醒

当G1变为waiting状态后，会创建一个代表自己的sudog的结构，然后放到sendq这个list中，sudog结构中保存了channel相关的变量的指针。当G2从ch中接收一个数据时，会通知调度器，设置G1的状态为runnable，然后将加入P的runqueue里，等待线程执行.

## 4. 源码篇

## 4.1. 切片的实现原理

## 4.2. map的实现原理

## 4.3. channel为什么是线程安全的？
